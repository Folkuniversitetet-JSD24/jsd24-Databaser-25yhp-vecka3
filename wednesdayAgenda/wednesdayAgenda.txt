🧾 Lektionsplanering – Onsdag 28 maj 2025
⏰ Tid: 13.00–16.00
🎯 Fokus: Kombinera modeller, djupare användning av .populate() och .aggregate()
🧠 Pedagogiskt fokus: fördjupning i relationer och databehandling i Mongoose, samt förberedelse inför examination

-----------------------------
🎯 Syfte

Koppla ihop flera modeller (User, Movie, Review) i relationsflöden

Använda .populate() på flera nivåer (t.ex. hämta både användare och film för en recension)

Skapa och förstå .aggregate()-pipelines (≈ SQL GROUP BY) med $group, $match, $sort, $project, $limit

Bygga rutter som sammanställer och strukturerar data

Träna på Postman-testning av relationer och sammanställningar

Förbereda inför kommande individuella examinationen

-----------------------------
🧠 Agenda

Code review (peer feedback)
Teori – CRUD + populate
Code-Along 1 – CRUD, ref
Teori + Code-Along 2 – .aggregate()
Självständig övning: pipelines
Examination & Q&A

-----------------------------
-----------------------------
-----------------------------
🧠 TEORI

🗣️ CRUD i Mongoose

“Mongoose ger oss enkla metoder för att skapa, läsa, uppdatera och ta bort dokument. Det påminner om ORM-verktyg i andra språk.”

.create(), .find(), .findById()

.findByIdAndUpdate(), .findByIdAndDelete()

.populate() – används för att hämta hela relaterade dokument

🗣️ Vad är .aggregate()?

“MongoDB:s aggregate() liknar SQL:s GROUP BY, JOIN, HAVING, men använder istället en pipeline av transformationer.”

“Vi skickar in en array med steg – varje steg är en transformation: $match, $group, $sort, $project, osv.”

En aggregation pipeline i MongoDB fungerar som ett produktionsband – varje steg modifierar datan och skickar vidare till nästa. Det är exakt som en kedja av .map(), .filter() och .sort() i JavaScript – men det sker direkt i databasen och är mycket effektivare.

📊 Jämförelse: SQL vs MongoDB

| SQL                      | MongoDB Mongoose                    |
|--------------------------|-------------------------------------|
| SELECT * FROM            | .find()                             |
| JOIN                     | .populate() eller $lookup           |
| GROUP BY category        | { $group: { _id: "$category" }}     |
| ORDER BY created_at      | { $sort: { createdAt: -1 }}         |
| SELECT col1, col2        | { $project: { col1: 1, col2: 1 }}   |

-----------------------------
-----------------------------
-----------------------------
💻 Code-Along – User, Movie, Review: CRUD + Ref + populate + aggregate

📁 Projektstruktur:
rootmappen/
├── models/
│   ├── User.js
│   ├── Movie.js
│   └── Review.js
├── index.js
├── .env

✅ MODELLER

models/User.js
Genomför den koden

models/Movie.js
Genomför den koden

models/Review.js
Genomför den koden

index.js
Genomför den koden

-----------------------------
-----------------------------
-----------------------------
✅ Verifiera att allt fungerar – Testa i Postman

1. Skapa en användare

Method: POST

URL: http://localhost:1212/users

Body (JSON):
{
  "name": "filmfan123",
  "email": "fan@example.com"
}

📌 Förväntat svar: 
{
  "succes": true,
  "message": "Användare skapad",
  "data": {
    "_id": "6837...",
    "name": "filmfan",
    "email": "filmfan@example.com",
    "__v": 0
  }
}

-----------------------------
2. Skapa film:

Method: POST

URL: http://localhost:3210/movies

Body (JSON):
{
  "title": "Interstellar",
  "genre": "Sci-Fi",
  "releaseYear": 2014,
  "director": "Christopher Nolan"
}


📌 Förväntat svar: 
{
  "succes": true,
  "message": "Film skapad",
  "data": {
    "_id": "6837...",
    "title": "Interstellar",
    "genre": "Sci-Fi",
    "releaseYear": 2014,
    "director": "Christopher Nolan",
    "__v": 0
  }
}

-----------------------------
3. Skapa recension:

Method: POST

URL: http://localhost:3210/reviews

Body (JSON):
{
  "rating": 5,
  "comment": "Magisk film!",
  "movieId": "<id från filmen>",
  "userId": "<id från användaren>"
}

📌 Förväntat svar: 
{
  "succes": true,
  "message": "Recension skapad",
  "data": {
    "_id": "6837...",
    "rating": 5,
    "comment": "Magisk film!",
    "movieId": "6837...",
    "userId": "6837...",
    "createdAt": "...",
    "updatedAt": "...",
    "__v": 0
  }
}

✅ Upprepa detta med flera olika betyg (t.ex. 3, 4, 5) men samma movieId.

-----------------------------
4. Hämta relationer

GET http://localhost:3210/reviews

En array där varje objekt innehåller en inbäddad user och movie med deras namn/titel.

Förväntat svar:
[
  {
    "rating": 5,
    "comment": "Magisk film!",
    "userId": { "name": "filmfan" },
    "movieId": { "title": "Interstellar" }
  },
  ...
]

-----------------------------
5. Hämta betygssammanställning

GET http://localhost:3210/movies/ratings

➜ Returnerar en array med filmer:
[
  {
    "title": "Interstellar",
    "genre": "Sci-Fi",
    "avgRating": 4.0,
    "reviewCount": 3
  }
]

-----------------------------
6. Topplista – endast bra filmer

Method: GET

URL: http://localhost:3210/movies/top-sci-fi

📌 Förväntat svar:
En array med max 3 filmer, där varje objekt innehåller:
[
  {
    "title": "Interstellar",
    "genre": "Sci-Fi",
    "avgRating": 4.0,
    "reviewCount": 3
  }
]

-----------------------------
7. /seed-review i Postman

🛠 Syfte:
Lägga in en dummy-recension utan att behöva skapa användare eller film manuellt.

Method: POST

URL: http://localhost:1212/seed-review

Body: (ingen behövs – den är hårdkodad i serverkoden)

📌 Förväntat svar, Om användaren med id 68371040fe398b566cb68260 och filmen med id 68371072fe398b566cb68262 finns i databasen:

{
  "succes": true,
  "message": "En recension skapad.",
  "data": {
    "_id": "...",
    "rating": 5,
    "comment": "EN SEEDAD film",
    "movieId": "68371072fe398b566cb68262",
    "userId": "68371040fe398b566cb68260",
    "createdAt": "...",
    "updatedAt": "...",
    "__v": 0
  }
}

❗ Om du får ett fel som:
{
  "succes": false,
  "error": "Movie validation failed: movieId: Cast to ObjectId failed..."
}
Då betyder det att objektet inte finns i databasen.

💡 Tips – skapa matchande data:
Skapa en användare i Postman och kopiera dess _id.

Skapa en film i Postman och kopiera dess _id.

Uppdatera koden i /seed-review med dessa värden:
movieId: new mongoose.Types.ObjectId("DIN_FILM_ID"),
userId: new mongoose.Types.ObjectId("DIN_USER_ID"),

-----------------------------
-----------------------------
-----------------------------
Dags för övningar

-----------------------------
-----------------------------
-----------------------------
🔁 Gruppdiskussion 

Varför inte bädda in recensioner direkt i filmen?

När är det bättre att använda .aggregate() än att hämta alla reviews och räkna själv i Node?